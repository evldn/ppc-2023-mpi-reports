\section{Программная реализация}
Программа состоит из заголовочного файла $chbi.h$ и двух исходных файлов $chbi.cpp$ и $main.cpp$.\n
В заголовочном файле определены функции, реализующие последовательный и параллельный подходы для нахождения выпуклой оболочки произвольного множества точек, а также вспомогательные функции: для выделения компонент изображения, для подсчета количества компонент, для сокращения числа точек, генерации примеров и другие.

\subsection{Функции для выделения компонент изображения}
\begin{minted}[breaklines, breakafter=d]{cpp}
std::vector<int> findComponents(const std::vector<std::vector<int>>& image, int width, int height);
\end{minted}
Функция $findComponents$ является не более чем общим интерфейсом. Она принимает на вход исходное изображение в виде двумерного вектора, его высоту и ширину. Весь процесс выполнения данной функции связан с вызовом для каждого пикселя процедуры $floodFill$. На выходе функция $findComponents$ возвращает промаркированное изображение в виде вектора.
\begin{minted}[breaklines, breakafter=d]{cpp}
void floodFill(std::vector<int>* image, int height, int width, int yStart, int xStart, int label);
\end{minted}
Процедура $floodFill$ выполняет основную работу, а именно принимает на вход изображение в виде указателя на вектор, его высоту и ширину, точку старта, с которой необходимо начать маркировку и метку, которая присваивается данной компоненте. Данная функция ничего не возвращает, так как изменяет изображение, переданное ей в качестве аргумента.

\subsection{Функции подсчета}
\begin{minted}[breaklines, breakafter=d]{cpp}
int findCountComponents(const std::vector<int> &image);
\end{minted}
Функция $findCountComponents$ используется для подсчета числа компонент в изображении. На вход принимается изображение в виде ссылки на вектор, а на выходе выдается число компонент в нем. Работает по принципу поиска компоненты с наибольшим номером метки.
\begin{minted}[breaklines, breakafter=d]{cpp}
int findCountPointsInComponent(const std::vector<int> &image);
\end{minted}
Функция $findCountPointsInComponent$ используется для подсчета числа точек в компоненте. На вход принимается компонента (в виде части изображения), а на выходе выдается число точек в ней. Работает по принципу подсчета ненулевых пикселей.

\subsection{Функция удаления лишний точек компоненты}
\begin{minted}[breaklines, breakafter=d]{cpp}
std::vector<int> removeExtraPoints(const std::vector<int> &image, int width, int height, int component);
\end{minted}
Функция $removeExtraPoints$ принимает на вход изображение в виде ссылки на вектор, его высоту и ширину, а также номер компоненты, которую необходимо оставить. На выходе получаем изображение в виде вектора, в котором число компонент уменьшено до минимума, что позволяет быстрее строить выпуклую оболочку.

\subsection{Функция алгоритма Грэхема}
\begin{minted}[breaklines, breakafter=d]{cpp}
void sort(std::vector<int>* points, int xMin, int yMin);
\end{minted}
Функция $sort$ является вспомогательной. Она сортирует точки в процессе работы алгоритма Грэхема. На вход функции подается вектор точек, а также координаты точки, относительно которой нужно выполнить сортировку. На выходе получаем отсортированный по нужному правилу вектор.
\begin{minted}[breaklines, breakafter=d]{cpp}
int cross(int x1, int y1, int x2, int y2, int x3, int y3);
\end{minted}
Функция $cross$ также является вспомогательной. С помощью нее определяется векторное произведение. На вход подаются координаты точек, а на выходе получаем их векторное произведение.
\begin{minted}[breaklines, breakafter=d]{cpp}
std::vector<int> graham(std::vector<int> points);
\end{minted}
Функция $graham$ является основной, поскольку реализует алгоритм Грэхема. Она принимает на вход вектор точек. На выходе данная функция возвращает вектор точек, входящих в выпуклую оболочку.

\subsection{Функция, реализующая последовательный подход}
\begin{minted}[breaklines, breakafter=d]{cpp}
std::vector<int> getConvexHullSeq(const std::vector<std::vector<int>> &image, int width, int height);
\end{minted}
Данная функция принимает на вход изображение в виде ссылки на вектор, его высоту и ширину. В процессе выполнения функции находятся его компоненты, и для каждой из них строится выпуклая оболочка. На выходе получаем вектор точек, которые образуют выпуклые оболочки для каждой компоненты.

\subsection{Функция, реализующая параллельную версию}
\begin{minted}[breaklines, breakafter=d]{cpp}
std::vector<int> getConvexHullPar(const std::vector<std::vector<int>> &image, int width, int height);
\end{minted}
Данная функция принимает на вход изображение в виде ссылки на вектор, его высоту и ширину. В процессе выполнения функции находятся его компоненты, и для каждой из них строится выпуклая оболочка. На выходе получаем вектор точек, которые образуют выпуклые оболочки для каждой компоненты.

\subsection{Функция заполнения изображения}
\begin{minted}[breaklines, breakafter=d]{cpp}
void fillImageRandom(std::vector<std::vector<int>>* image, int width, int height);
\end{minted}
Функция $fillImageRandom$ заполняет изображение единицами и нулями. На вход она принимает пустое изображение в виде ссылки на двумерный вектор, его высоту и ширину. Эта функция ничего не возвращает, поскольку изменяет непосредственно принятое изображение.